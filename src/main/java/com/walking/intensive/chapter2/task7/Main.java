package com.walking.intensive.chapter2.task7;

/*КУРСОВАЯ ЗАДАЧА - ДРУЖЕСТВЕННАЯ ПАРА

Пятиклассник Ваня придумал забаву. Он ввел понятие "дружественной пары" чисел. Два различных натуральных числа n и m он
назвал дружественными, если сумма делителей числа n (включая 1, но исключая само n) равна числу m и наоборот.
Например, 220 и 284 – дружественные числа:
Cписок делителей для 220: 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110 и их сумма равна 284;
Cписок делителей для 284: 1, 2, 4, 71, 142 и сумма равна 220.
Максимальное дружественное число из пары не должно превышать N, где N число, вводимое в метод в качестве аргумента.
(N < 1 000 000)
Метод должен вернуть наибольшее число из пары дружественных чисел, сумма дружественных чисел которой максимальна среди
всех пар дружественных чисел, большее из которых меньше N.
P.S. Не использовать массивы и прочие темы, которые пока не были затронуты в курсе.

 */
public class Main {
    public static void main(String[] args) {

        int n1 = 220;
        int n2 = 285;
        int n3 = 1211;
        int n4 = 2925;
        int n5 = 5565;

        solutionTask7(n1);
        solutionTask7(n2);
        solutionTask7(n3);
        solutionTask7(n4);
        solutionTask7(n5);
    }

    //проверка двух чисел на наличие пары
    public static boolean isAmicableNumbers(int a, int b) {

        return (getDividersSum(a) == b && getDividersSum(b) == a);
    }

    //поиск суммы делителей заданного n
    public static int getDividersSum(int n) {

        int result = 0;

        for (int i = 1; i < n; i++) {
            if (n % i == 0) {
                result += i;
            }
        }
        return result;
    }

    /*
    "...сумма дружественных чисел которой максимальна среди всех пар дружественных чисел".
    Как будто можно обойтись без этого условия и без метода getAmicableNumbersSum(). Не вычислять сумму, а просто найти
    ближайшее к n число (двигаясь n -> 1), входящее в пару и являющееся в такой паре бОльшим числом. Сумма
    чисел в такой паре будет больше, чем сумма чисел в следующей паре.
    Или я неверно понял условия. Метод оставлю для археологов.
     */
    public static int getAmicableNumbersSum(int a, int b) {

        return a + b;
    }

    public static int getMaxValueOfAmicablePairLessThanN(int n) {

        for (int i = n - 1; i > 0; i--) { //

            //Ищем сумму делителей i, сравниваем ее с i на наличие дружественной пары
            if (isAmicableNumbers(i, getDividersSum(i))) {
                //Проверяем, является ли i максимальным значением в паре. Возвращаем, если да
                if (getDividersSum(i) < i) {
                    return i;
                }
            }
        }
        //заглушка, не должно сработать никогда
        return 1;
    }

    //при n < 285 не должно быть подходящего ответа
    public static void solutionTask7(int n) {
        if (n > 284) {
            System.out.println(getMaxValueOfAmicablePairLessThanN(n));
        } else {
            System.out.println("Для введенного вами числа не существует дружественной пары, удовлетворяющей условиям");
        }
    }
}